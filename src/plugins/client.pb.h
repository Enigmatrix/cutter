// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#ifndef PROTOBUF_client_2eproto__INCLUDED
#define PROTOBUF_client_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_client_2eproto();
void protobuf_AssignDesc_client_2eproto();
void protobuf_ShutdownFile_client_2eproto();

class CommentAdded;
class CommentDeleted;
class Message;

// ===================================================================

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum BodyCase {
    kCommentAdded = 8,
    kCommentDeleted = 9,
    BODY_NOT_SET = 0,
  };

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 2;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional .CommentAdded commentAdded = 8;
  bool has_commentadded() const;
  void clear_commentadded();
  static const int kCommentAddedFieldNumber = 8;
  const ::CommentAdded& commentadded() const;
  ::CommentAdded* mutable_commentadded();
  ::CommentAdded* release_commentadded();
  void set_allocated_commentadded(::CommentAdded* commentadded);

  // optional .CommentDeleted commentDeleted = 9;
  bool has_commentdeleted() const;
  void clear_commentdeleted();
  static const int kCommentDeletedFieldNumber = 9;
  const ::CommentDeleted& commentdeleted() const;
  ::CommentDeleted* mutable_commentdeleted();
  ::CommentDeleted* release_commentdeleted();
  void set_allocated_commentdeleted(::CommentDeleted* commentdeleted);

  BodyCase body_case() const;
  // @@protoc_insertion_point(class_scope:Message)
 private:
  inline void set_has_commentadded();
  inline void set_has_commentdeleted();

  inline bool has_body() const;
  void clear_body();
  inline void clear_has_body();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  union BodyUnion {
    BodyUnion() {}
    ::CommentAdded* commentadded_;
    ::CommentDeleted* commentdeleted_;
  } body_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class CommentAdded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CommentAdded) */ {
 public:
  CommentAdded();
  virtual ~CommentAdded();

  CommentAdded(const CommentAdded& from);

  inline CommentAdded& operator=(const CommentAdded& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentAdded& default_instance();

  void Swap(CommentAdded* other);

  // implements Message ----------------------------------------------

  inline CommentAdded* New() const { return New(NULL); }

  CommentAdded* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentAdded& from);
  void MergeFrom(const CommentAdded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommentAdded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::google::protobuf::uint64 addr() const;
  void set_addr(::google::protobuf::uint64 value);

  // optional string cmt = 2;
  void clear_cmt();
  static const int kCmtFieldNumber = 2;
  const ::std::string& cmt() const;
  void set_cmt(const ::std::string& value);
  void set_cmt(const char* value);
  void set_cmt(const char* value, size_t size);
  ::std::string* mutable_cmt();
  ::std::string* release_cmt();
  void set_allocated_cmt(::std::string* cmt);

  // @@protoc_insertion_point(class_scope:CommentAdded)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 addr_;
  ::google::protobuf::internal::ArenaStringPtr cmt_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CommentAdded* default_instance_;
};
// -------------------------------------------------------------------

class CommentDeleted : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:CommentDeleted) */ {
 public:
  CommentDeleted();
  virtual ~CommentDeleted();

  CommentDeleted(const CommentDeleted& from);

  inline CommentDeleted& operator=(const CommentDeleted& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommentDeleted& default_instance();

  void Swap(CommentDeleted* other);

  // implements Message ----------------------------------------------

  inline CommentDeleted* New() const { return New(NULL); }

  CommentDeleted* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommentDeleted& from);
  void MergeFrom(const CommentDeleted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommentDeleted* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  ::google::protobuf::uint64 addr() const;
  void set_addr(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:CommentDeleted)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint64 addr_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static CommentDeleted* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Message

// optional string username = 2;
inline void Message::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::username() const {
  // @@protoc_insertion_point(field_get:Message.username)
  return username_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_username(const ::std::string& value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Message.username)
}
inline void Message::set_username(const char* value) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Message.username)
}
inline void Message::set_username(const char* value, size_t size) {
  
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Message.username)
}
inline ::std::string* Message::mutable_username() {
  
  // @@protoc_insertion_point(field_mutable:Message.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_username() {
  // @@protoc_insertion_point(field_release:Message.username)
  
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    
  } else {
    
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:Message.username)
}

// optional .CommentAdded commentAdded = 8;
inline bool Message::has_commentadded() const {
  return body_case() == kCommentAdded;
}
inline void Message::set_has_commentadded() {
  _oneof_case_[0] = kCommentAdded;
}
inline void Message::clear_commentadded() {
  if (has_commentadded()) {
    delete body_.commentadded_;
    clear_has_body();
  }
}
inline  const ::CommentAdded& Message::commentadded() const {
  // @@protoc_insertion_point(field_get:Message.commentAdded)
  return has_commentadded()
      ? *body_.commentadded_
      : ::CommentAdded::default_instance();
}
inline ::CommentAdded* Message::mutable_commentadded() {
  if (!has_commentadded()) {
    clear_body();
    set_has_commentadded();
    body_.commentadded_ = new ::CommentAdded;
  }
  // @@protoc_insertion_point(field_mutable:Message.commentAdded)
  return body_.commentadded_;
}
inline ::CommentAdded* Message::release_commentadded() {
  // @@protoc_insertion_point(field_release:Message.commentAdded)
  if (has_commentadded()) {
    clear_has_body();
    ::CommentAdded* temp = body_.commentadded_;
    body_.commentadded_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_commentadded(::CommentAdded* commentadded) {
  clear_body();
  if (commentadded) {
    set_has_commentadded();
    body_.commentadded_ = commentadded;
  }
  // @@protoc_insertion_point(field_set_allocated:Message.commentAdded)
}

// optional .CommentDeleted commentDeleted = 9;
inline bool Message::has_commentdeleted() const {
  return body_case() == kCommentDeleted;
}
inline void Message::set_has_commentdeleted() {
  _oneof_case_[0] = kCommentDeleted;
}
inline void Message::clear_commentdeleted() {
  if (has_commentdeleted()) {
    delete body_.commentdeleted_;
    clear_has_body();
  }
}
inline  const ::CommentDeleted& Message::commentdeleted() const {
  // @@protoc_insertion_point(field_get:Message.commentDeleted)
  return has_commentdeleted()
      ? *body_.commentdeleted_
      : ::CommentDeleted::default_instance();
}
inline ::CommentDeleted* Message::mutable_commentdeleted() {
  if (!has_commentdeleted()) {
    clear_body();
    set_has_commentdeleted();
    body_.commentdeleted_ = new ::CommentDeleted;
  }
  // @@protoc_insertion_point(field_mutable:Message.commentDeleted)
  return body_.commentdeleted_;
}
inline ::CommentDeleted* Message::release_commentdeleted() {
  // @@protoc_insertion_point(field_release:Message.commentDeleted)
  if (has_commentdeleted()) {
    clear_has_body();
    ::CommentDeleted* temp = body_.commentdeleted_;
    body_.commentdeleted_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_commentdeleted(::CommentDeleted* commentdeleted) {
  clear_body();
  if (commentdeleted) {
    set_has_commentdeleted();
    body_.commentdeleted_ = commentdeleted;
  }
  // @@protoc_insertion_point(field_set_allocated:Message.commentDeleted)
}

inline bool Message::has_body() const {
  return body_case() != BODY_NOT_SET;
}
inline void Message::clear_has_body() {
  _oneof_case_[0] = BODY_NOT_SET;
}
inline Message::BodyCase Message::body_case() const {
  return Message::BodyCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommentAdded

// optional uint64 addr = 1;
inline void CommentAdded::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CommentAdded::addr() const {
  // @@protoc_insertion_point(field_get:CommentAdded.addr)
  return addr_;
}
inline void CommentAdded::set_addr(::google::protobuf::uint64 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:CommentAdded.addr)
}

// optional string cmt = 2;
inline void CommentAdded::clear_cmt() {
  cmt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CommentAdded::cmt() const {
  // @@protoc_insertion_point(field_get:CommentAdded.cmt)
  return cmt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommentAdded::set_cmt(const ::std::string& value) {
  
  cmt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:CommentAdded.cmt)
}
inline void CommentAdded::set_cmt(const char* value) {
  
  cmt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:CommentAdded.cmt)
}
inline void CommentAdded::set_cmt(const char* value, size_t size) {
  
  cmt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:CommentAdded.cmt)
}
inline ::std::string* CommentAdded::mutable_cmt() {
  
  // @@protoc_insertion_point(field_mutable:CommentAdded.cmt)
  return cmt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CommentAdded::release_cmt() {
  // @@protoc_insertion_point(field_release:CommentAdded.cmt)
  
  return cmt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CommentAdded::set_allocated_cmt(::std::string* cmt) {
  if (cmt != NULL) {
    
  } else {
    
  }
  cmt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmt);
  // @@protoc_insertion_point(field_set_allocated:CommentAdded.cmt)
}

// -------------------------------------------------------------------

// CommentDeleted

// optional uint64 addr = 1;
inline void CommentDeleted::clear_addr() {
  addr_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CommentDeleted::addr() const {
  // @@protoc_insertion_point(field_get:CommentDeleted.addr)
  return addr_;
}
inline void CommentDeleted::set_addr(::google::protobuf::uint64 value) {
  
  addr_ = value;
  // @@protoc_insertion_point(field_set:CommentDeleted.addr)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eproto__INCLUDED
